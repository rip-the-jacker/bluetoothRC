// This class is only for the US Keyboard layout.
import static java.awt.event.KeyEvent.*;
import java.util.*;

class ConstantMapping
{
  //array of characters that do not have same value as their corresponding Event keycodes.
  private static final int [] unicode = {'!','*','\'','"','/','\\','&','$',' ','-','?','.'};
  
  //array of event keycodes for the corresponding character array element.
  private static final int [] events = {VK_EXCLAMATION_MARK,VK_ASTERISK,VK_QUOTE,VK_QUOTEDBL,VK_SLASH,VK_BACK_SLASH,VK_AMPERSAND,VK_DOLLAR,VK_SPACE,VK_MINUS,VK_SLASH,VK_PERIOD};
  
  //array of booleans that represent if a character is present on the secondary layer of keyboard
  //if it is true then it is on secondary layer and requires the shift+ modifier. 
  //eg. '!' is on secondary layer of key 1 and hence its value is true.
  private static final boolean [] secondaryLayer = {true, true, false, true, false, false, true, true, false, false, true, false};

  //returns the Event keycode for the given character.
  //If using the Robot interface then even if a secondary key has a different keycode.it generates the same
  // event as that generated by its primary key.
  //eg.keycodes of '1' and '!' are different but they generate the same event.
  //use the isSecondary(int ) method.
  public static int unicodeToEvent(int unigen)
  {
    int eventgen = VK_ESCAPE;
    for(int i = 0; i < unicode.length; i++)
    {
      if(unicode[i] == unigen)
      {
	eventgen =  events[i];
	break;
      }
    }
    return eventgen;
  }
  
  //determines whether the character is present on the secondary layer of keyboard.
  //if retured true the event generater may require the shift modifier to print the character.
  public static boolean isSecondary(int unigen)
  {
    boolean boolgen = false;
    for(int i = 0; i < unicode.length; i++)
    {
      if(unicode[i] == unigen)
      {
	boolgen =  secondaryLayer[i];
	break;
      }
    }
    return boolgen;
  }
}
